/*---------------------------------------------------------------------------------------------
 *  Copyright (C) 2023-2025 Posit Software, PBC. All rights reserved.
 *  Licensed under the Elastic License 2.0. See LICENSE.txt for license information.
 *--------------------------------------------------------------------------------------------*/

import { Disposable, IDisposable } from '../../../../base/common/lifecycle.js';
import { Event, Emitter } from '../../../../base/common/event.js';
import { IErdosPlotClient, IZoomablePlotClient, ZoomLevel } from '../../erdosPlots/common/erdosPlots.js';
import { IntrinsicSize, PlotResult, PlotRenderFormat, PlotSize } from './erdosPlotComm.js';
import { IPlotSize, IErdosPlotSizingPolicy } from '../../erdosPlots/common/sizingPolicy.js';
import { ErdosPlotCommProxy } from './erdosPlotCommProxy.js';
import { PlotSizingPolicyCustom } from '../../erdosPlots/common/sizingPolicyCustom.js';
import { DeferredRender, IRenderedPlot, RenderRequest } from './erdosPlotRenderQueue.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';

export const FreezeSlowPlotsConfigKey = 'erdos.plots.freezeSlowPlots';

export enum PlotClientLocation {
	/** The plot is in the editor */
	Editor,

	/** The plot is in the Plots view */
	View
}
/**
 * The possible states for the plot client instance
 */
export enum PlotClientState {
	/** The plot client has never rendered a plot */
	Unrendered = 'unrendered',

	/** The plot client has been requested to render a plot, but hasn't done it yet. */
	RenderPending = 'render_pending',

	/** The plot client is currently rendering a plot */
	Rendering = 'rendering',

	/** The plot client has rendered a plot */
	Rendered = 'rendered',

	/** The plot client is closed (disconnected); it cannot render any further plots */
	Closed = 'closed',
}

/** The metadata associated with an Erdos plot */
export interface IErdosPlotMetadata {
	/** The plot's unique ID, as supplied by the language runtime */
	id: string;

	/** The plot's moment of creation, in milliseconds since the Epoch */
	created: number;

	/** The code that created the plot, if known. */
	code: string;

	/** The plot's parent message ID; useful for jumping to associated spot in the console */
	parent_id: string;

	/** The ID of the runtime session that created the plot */
	session_id: string;

	/** The sizing policy for the plot. This may not be present with older metadata. */
	sizing_policy?: {
		id: string;
		size?: IPlotSize;
	};

	/** The plot's location for display. */
	location?: PlotClientLocation;

	/** The pre-rendering of the plot for initial display, if any. */
	pre_render?: PlotResult;

	/** The suggested file name of the plot. */
	suggested_file_name?: string;

	/** The optional output identifier of the plot. */
	output_id?: string;

	/** The language of the session */
	language?: string;

	/** The zoom level for displaying the plot */
	zoom_level?: ZoomLevel;
}

/**
 * An instance of a plot client widget generated by a language runtime. A plot can be rendered
 * by calling the `render` method, which returns a promise that resolves to the rendered plot.
 */
export class PlotClientInstance extends Disposable implements IErdosPlotClient, IZoomablePlotClient {
	/**
	 * The currently active render request, if any.
	 */
	private _currentRender?: DeferredRender;

	/**
	 * The queued render request, if any.
	 */
	private _queuedRender?: DeferredRender;

	/**
	 * The last rendered plot, if any.
	 */
	private _lastRender?: IRenderedPlot;

	/**
	 * The timer used to throttle plot rendering requests.
	 */
	private _renderThrottleTimer?: Timeout;

	/**
	 * The current state of the plot client.
	 */
	private _state: PlotClientState = PlotClientState.Unrendered;

	/**
	 * The time it took to render the plot the last time it was rendered, in milliseconds.
	 */
	private _lastRenderTimeMs: number = 0;

	/**
	 * Event that fires when the plot is closed on the runtime side, typically
	 * because the runtime exited and doesn't preserve plot state.
	 */
	onDidClose: Event<void>;
	private readonly _closeEmitter = new Emitter<void>();

	/**
	 * Event that fires when the state of the plot client changes.
	 */
	onDidChangeState: Event<PlotClientState>;
	private readonly _stateEmitter = new Emitter<PlotClientState>();

	/**
	 * Event that fires when the plot has finished rendering.
	 */
	onDidCompleteRender: Event<IRenderedPlot>;
	private readonly _completeRenderEmitter = new Emitter<IRenderedPlot>();

	/**
	 * Event that fires when the plot has been updated by the runtime and
	 * re-rendered. Note that this complements rather than replaces the
	 * `onDidCompleteRender` event, which fires for every render (user-initiated
	 * or runtime-initiated)
	 */
	onDidRenderUpdate: Event<IRenderedPlot>;
	private readonly _renderUpdateEmitter = new Emitter<IRenderedPlot>();

	/**
	 * Event that fires when the runtime sent a show event.
	 */
	onDidShowPlot: Event<void>;
	private readonly _didShowPlotEmitter = new Emitter<void>();

	/**
	 * Event that fires when the intrinsic size of the plot is set.
	 */
	onDidSetIntrinsicSize: Event<IntrinsicSize | undefined>;
	private readonly _didSetIntrinsicSizeEmitter = new Emitter<IntrinsicSize | undefined>();

	/**
	 * Event that fires when the sizing policy is changed.
	 */
	onDidChangeSizingPolicy: Event<IErdosPlotSizingPolicy>;
	private readonly _sizingPolicyEmitter = new Emitter<IErdosPlotSizingPolicy>;

	/**
	 * Event that fires when the zoom level is changed.
	 */
	onDidChangeZoomLevel: Event<ZoomLevel>;
	private readonly _zoomLevelEmitter = new Emitter<ZoomLevel>();

	/**
	 * Creates a new plot client instance.
	 *
	 * @param _commProxy The proxy than handles comm requests
	 * @param metadata The plot's metadata
	 */
	constructor(
		private readonly _commProxy: ErdosPlotCommProxy,
		private readonly _configurationService: IConfigurationService,
		private _sizingPolicy: IErdosPlotSizingPolicy,
		public readonly metadata: IErdosPlotMetadata
	) {
		super();
		// If the plot comes with a pre-rendering, set it as the last render. This
		// will be picked up automatically by the plot instance component. This is
		// also used to bypass render request if the pre-rendering render policy
		// (size, pixel ratio, and format) matches.
		if (metadata.pre_render) {
			const preRender = metadata.pre_render;

			// The policy should normally be defined in a pre-render result but we
			// check just in case
			if (preRender.settings) {
				const uri = `data:${preRender.mime_type};base64,${preRender.data}`;
				this._lastRender = {
					uri,
					size: preRender.settings.size,
					pixel_ratio: preRender.settings.pixel_ratio,
					renderTimeMs: 0,
				};
			}
		}

		// Connect close emitter event
		this.onDidClose = this._closeEmitter.event;
		this._register(this._commProxy.onDidClose((state) => {
			this._closeEmitter.fire();

			// Silently cancel any pending render requests
			this._currentRender?.cancel();
			this._stateEmitter.fire(PlotClientState.Closed);
		}));

		// Connect the state emitter event
		this.onDidChangeState = this._stateEmitter.event;

		// Connect the complete render emitter event
		this.onDidCompleteRender = this._completeRenderEmitter.event;

		// Connect the render update emitter event
		this.onDidRenderUpdate = this._renderUpdateEmitter.event;

		// Connect the show plot emitter event
		this.onDidShowPlot = this._didShowPlotEmitter.event;

		// Connect the intrinsic size emitter event
		this.onDidSetIntrinsicSize = this._didSetIntrinsicSizeEmitter.event;

		// Connect the sizing policy emitter event
		this.onDidChangeSizingPolicy = this._sizingPolicyEmitter.event;

		// Connect the zoom level emitter event
		this.onDidChangeZoomLevel = this._zoomLevelEmitter.event;

		// Listen to our own state changes
		this._register(this.onDidChangeState((state) => {
			this._state = state;
		}));

		let needsSelect = true;

		// Listen for plot updates
		this._register(this._commProxy.onDidRenderUpdate(async (evt) => {
			const preRender = evt.pre_render;

			// If there's a pre-rendering, check if we can use it for immediate display
			if (preRender && preRender.settings) {
				const uri = `data:${preRender.mime_type};base64,${preRender.data}`;
				const preRenderPlot: IRenderedPlot = {
					uri,
					size: preRender.settings.size,
					pixel_ratio: preRender.settings.pixel_ratio,
					renderTimeMs: 0,
				};

				// Store the pre-rendering as the last render
				this._lastRender = preRenderPlot;

				// Fire the complete render event to actually update the plot instance
				this._completeRenderEmitter.fire(preRenderPlot);

				// Fire the render update event to select the updated plot in the UI
				this._renderUpdateEmitter.fire(preRenderPlot);

				// Check if the current render settings match
				const currentRenderRequest = this._currentRender?.renderRequest ?? this._lastRender;

				if (currentRenderRequest && this.settingsEqual(
					preRender.settings,
					currentRenderRequest
				)) {
					return;
				}

				// Otherwise fallthrough. But don't select plot again to avoid
				// unexpected jerkiness.
				needsSelect = false;
			}

			// No pre-rendering or settings mismatch: Queue a render request
			const rendered = await this.queuePlotUpdateRequest();

			// Fire the update event to select it in the UI
			if (needsSelect) {
				this._renderUpdateEmitter.fire(rendered);
			}
		}));

		// Listen for plot show events
		this._register(this._commProxy.onDidShowPlot(async (_evt) => {
			this._didShowPlotEmitter.fire();
		}));
	}

	/**
	 * Get the intrinsic size of the plot, if known.
	 *
	 * @returns A promise that resolves to the intrinsic size of the plot, if known.
	 */
	public getIntrinsicSize(): Promise<IntrinsicSize | undefined> {
		return this._commProxy.getIntrinsicSize();
	}

	get sizingPolicy() {
		return this._sizingPolicy;
	}

	set sizingPolicy(newSizingPolicy: IErdosPlotSizingPolicy) {
		this._sizingPolicy = newSizingPolicy;
		this.metadata.sizing_policy = {
			id: newSizingPolicy.id,
			size: newSizingPolicy instanceof PlotSizingPolicyCustom ? newSizingPolicy.size : undefined
		};
		this._sizingPolicyEmitter.fire(newSizingPolicy);
	}

	public renderWithSizingPolicy(size: IPlotSize | undefined, pixel_ratio: number, format = PlotRenderFormat.Png, preview = false): Promise<IRenderedPlot> {
		return this.render(size ? this._sizingPolicy.getPlotSize(size) : size, pixel_ratio, format, preview);
	}

	/**
	 * Requests that the plot be rendered at a specific size.
	 *
	 * @param size The plot size, in pixels. If undefined, the plot will be rendered at its intrinsic size.
	 * @param height The plot height, in pixels
	 * @param width The plot width, in pixels
	 * @param pixel_ratio The device pixel ratio (e.g. 1 for standard displays, 2 for retina displays)
	 * @param format The format of the plot ('png', 'svg')
	 * @param preview If true, the plot will be rendered but not stored and no events are emitted.
	 * @returns A promise that resolves to a rendered image, or rejects with an error.
	 */

	/**
	 * Check if the render settings match
	 */
	private settingsEqual(
		left: { size?: PlotSize; pixel_ratio: number; format?: PlotRenderFormat },
		right: { size?: PlotSize; pixel_ratio: number; format?: PlotRenderFormat },
	): boolean {
		if (left.size?.height !== right.size?.height) {
			return false;
		}
		if (left.size?.width !== right.size?.width) {
			return false;
		}
		if (left.pixel_ratio !== right.pixel_ratio) {
			return false;
		}
		return true;
	}

	public render(size: IPlotSize | undefined, pixel_ratio: number, format = PlotRenderFormat.Png, preview = false): Promise<IRenderedPlot> {
		// Deal with whole pixels only
		const sizeInt = size && {
			height: Math.floor(size.height),
			width: Math.floor(size.width)
		};

		// Compare against the last render request. It is normal for the same
		// render request to be made multiple times, e.g. when the UI component
		// is redrawn without changing the plot size.
		if (sizeInt && this._lastRender?.size && this._lastRender && this.settingsEqual(
			{ size: sizeInt, pixel_ratio, format },
			this._lastRender
		)) {
			// The last render request was the same size; return the last render
			// result without performing another render.
			return Promise.resolve(this._lastRender);
		}

		// Create a new deferred promise to track the render request
		const request: RenderRequest = {
			size: sizeInt,
			pixel_ratio,
			format
		};
		const deferred = new DeferredRender(request);

		// Check which render request is currently pending. If we are currently
		// rendering, then it's the queued render request. Otherwise, it's the
		// current render request.
		const pending = this._state === PlotClientState.Rendering ?
			this._queuedRender : this._currentRender;

		// If there is already a render request in flight, cancel it; this
		// request supercedes it.
		if (pending && !pending.isComplete) {
			pending.cancel();
		}

		if (this._state === PlotClientState.Rendering) {
			// We are currently rendering; don't start another render until we're done.
			this._queuedRender = deferred;
		} else {
			// We are not currently rendering; start a new render. Render
			// immediately if we have never rendered before; otherwise, throttle
			// (debounce) the render.
			this._currentRender = deferred;
			this.scheduleRender(deferred, this._state === PlotClientState.Unrendered ? 0 : 500, preview);
		}

		return deferred.promise;
	}

	/**
	 * Schedules the render request to be performed after a short delay.
	 *
	 * @param request The render request to schedule
	 * @param delay The delay, in milliseconds
	 */
	private scheduleRender(request: DeferredRender, delay: number, preview = false) {
		// If there is a render throttle timer, clear it
		if (this._renderThrottleTimer) {
			clearTimeout(this._renderThrottleTimer);
		}

		// If this is the first render request, perform it immediately. Otherwise,
		// throttle the request.
		this._stateEmitter.fire(PlotClientState.RenderPending);
		this._renderThrottleTimer = setTimeout(() => {
			this._stateEmitter.fire(PlotClientState.Rendering);

			request.promise.then((rendered) => {
				const frozen = this._configurationService.getValue(FreezeSlowPlotsConfigKey);

				if (rendered.renderTimeMs > 3000 && rendered.size && !this._lastRender && frozen) {
					// Set sizing policy to the current size to avoid redraws
					this.sizingPolicy = new PlotSizingPolicyCustom(rendered.size, true);
				}
				this._stateEmitter.fire(PlotClientState.Rendered);
				if (!preview) {
					this._lastRender = rendered;
					this._lastRenderTimeMs = rendered.renderTimeMs;
					this._completeRenderEmitter.fire(rendered);
				}
			}).catch((err) => {
				this._stateEmitter.fire(PlotClientState.Rendered);
			});

			this._commProxy.render(request);
		}, delay);
	}

	/**
	 * Returns the last rendered plot, if any.
	 */
	get lastRender(): IRenderedPlot | undefined {
		return this._lastRender;
	}

	/**
	 * Returns the plot's unique ID.
	 */
	get id(): string {
		return this.metadata.id;
	}

	/**
	 * Returns an estimate for the time it will take to render the plot, in milliseconds.
	 *
	 * Currently, this is just the time it took for the last succesful render to
	 * complete. In the future, we may want to use a more sophisticated
	 * algorithm to estimate the render time.
	 */
	get renderEstimateMs(): number {
		return this._lastRenderTimeMs;
	}

	/**
	 * Returns the intrinsic size of the plot, if known.
	 */
	get intrinsicSize(): IntrinsicSize | undefined {
		return this._commProxy.intrinsicSize;
	}

	/**
	 * Returns a boolean indicating whether this plot has a known intrinsic size.
	 */
	get receivedIntrinsicSize(): boolean {
		return this._commProxy.receivedIntrinsicSize;
	}

	/**
	 * Queues a plot update request, if necessary. Returns a promise that
	 * resolves with the rendered plot.
	 */
	private queuePlotUpdateRequest(): Promise<IRenderedPlot> {
		if (this._queuedRender) {
			// There is already a queued render request; it will take care of
			// updating the plot.
			return this._queuedRender.promise;
		}

		// If we have never rendered this plot, we can't process any updates
		// yet.
		const render = this._currentRender?.renderRequest ?? this._lastRender;
		if (!render) {
			return Promise.reject(new Error('Cannot update plot before it has been rendered'));
		}

		// Use the dimensions of the last or current render request to determine
		// the size and DPI of the plot to update.
		const sizeInt = render.size && {
			height: Math.floor(render.size.height),
			width: Math.floor(render.size.width)
		};
		const pixel_ratio = render.pixel_ratio;

		// If there is already a render request in flight, cancel it. This
		// should be exceedingly rare since if the kernel is busy processing a
		// render request, it is unlikely that it will also -- simultaneously --
		// be processing a request from the user that changes the plot.
		if (this._currentRender && !this._currentRender.isComplete) {
			this._currentRender.cancel();
			this._currentRender = undefined;
		}

		// Create and schedule a render request to update the plot, and execute
		// it right away. `scheduleRender` takes care of cancelling the render
		// timer for any previously deferred render requests.
		const req = new DeferredRender({
			size: sizeInt,
			pixel_ratio: pixel_ratio,
			format: this._currentRender?.renderRequest.format ?? PlotRenderFormat.Png
		});

		this.scheduleRender(req, 0);
		return req.promise;
	}

	set zoomLevel(level: ZoomLevel) {
		if (this.metadata.zoom_level !== level) {
			this.metadata.zoom_level = level;
			this._zoomLevelEmitter.fire(level);
		}
	}

	get zoomLevel(): ZoomLevel {
		return this.metadata.zoom_level ?? ZoomLevel.Fit;
	}

	override dispose(): void {
		this._closeEmitter.fire();
		super.dispose();
	}

	/**
	 * Register a resource for cleanup on disposal.
	 */
	public register<T extends IDisposable>(o: T): T {
		return this._register(o);
	}
}